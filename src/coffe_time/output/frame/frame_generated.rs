// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod coffee_time {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod output {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod frame {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum SoundOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Sound<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Sound<'a> {
  type Inner = Sound<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Sound<'a> {
  pub const VT_CAN_PLAY: flatbuffers::VOffsetT = 4;
  pub const VT_PATH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Sound { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SoundArgs<'args>
  ) -> flatbuffers::WIPOffset<Sound<'bldr>> {
    let mut builder = SoundBuilder::new(_fbb);
    if let Some(x) = args.path { builder.add_path(x); }
    builder.add_can_play(args.can_play);
    builder.finish()
  }


  #[inline]
  pub fn can_play(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Sound::VT_CAN_PLAY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sound::VT_PATH, None)}
  }
}

impl flatbuffers::Verifiable for Sound<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("can_play", Self::VT_CAN_PLAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .finish();
    Ok(())
  }
}
pub struct SoundArgs<'a> {
    pub can_play: bool,
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SoundArgs<'a> {
  #[inline]
  fn default() -> Self {
    SoundArgs {
      can_play: false,
      path: None,
    }
  }
}

pub struct SoundBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SoundBuilder<'a, 'b> {
  #[inline]
  pub fn add_can_play(&mut self, can_play: bool) {
    self.fbb_.push_slot::<bool>(Sound::VT_CAN_PLAY, can_play, false);
  }
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sound::VT_PATH, path);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SoundBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SoundBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Sound<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Sound<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Sound");
      ds.field("can_play", &self.can_play());
      ds.field("path", &self.path());
      ds.finish()
  }
}
pub enum CoordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Coord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Coord<'a> {
  type Inner = Coord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Coord<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Coord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CoordArgs
  ) -> flatbuffers::WIPOffset<Coord<'bldr>> {
    let mut builder = CoordBuilder::new(_fbb);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Coord::VT_X, Some(0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Coord::VT_Y, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Coord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("x", Self::VT_X, false)?
     .visit_field::<i32>("y", Self::VT_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct CoordArgs {
    pub x: i32,
    pub y: i32,
}
impl<'a> Default for CoordArgs {
  #[inline]
  fn default() -> Self {
    CoordArgs {
      x: 0,
      y: 0,
    }
  }
}

pub struct CoordBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CoordBuilder<'a, 'b> {
  #[inline]
  pub fn add_x(&mut self, x: i32) {
    self.fbb_.push_slot::<i32>(Coord::VT_X, x, 0);
  }
  #[inline]
  pub fn add_y(&mut self, y: i32) {
    self.fbb_.push_slot::<i32>(Coord::VT_Y, y, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CoordBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CoordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Coord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Coord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Coord");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.finish()
  }
}
pub enum SpriteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Sprite<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Sprite<'a> {
  type Inner = Sprite<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Sprite<'a> {
  pub const VT_POSITION: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 6;
  pub const VT_IS_HIDDEN: flatbuffers::VOffsetT = 8;
  pub const VT_PATH: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Sprite { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SpriteArgs<'args>
  ) -> flatbuffers::WIPOffset<Sprite<'bldr>> {
    let mut builder = SpriteBuilder::new(_fbb);
    if let Some(x) = args.path { builder.add_path(x); }
    if let Some(x) = args.size_ { builder.add_size_(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    builder.add_is_hidden(args.is_hidden);
    builder.finish()
  }


  #[inline]
  pub fn position(&self) -> Option<Coord<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Coord>>(Sprite::VT_POSITION, None)}
  }
  #[inline]
  pub fn size_(&self) -> Option<Size<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Size>>(Sprite::VT_SIZE_, None)}
  }
  #[inline]
  pub fn is_hidden(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Sprite::VT_IS_HIDDEN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Sprite::VT_PATH, None)}
  }
}

impl flatbuffers::Verifiable for Sprite<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Coord>>("position", Self::VT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Size>>("size_", Self::VT_SIZE_, false)?
     .visit_field::<bool>("is_hidden", Self::VT_IS_HIDDEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .finish();
    Ok(())
  }
}
pub struct SpriteArgs<'a> {
    pub position: Option<flatbuffers::WIPOffset<Coord<'a>>>,
    pub size_: Option<flatbuffers::WIPOffset<Size<'a>>>,
    pub is_hidden: bool,
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SpriteArgs<'a> {
  #[inline]
  fn default() -> Self {
    SpriteArgs {
      position: None,
      size_: None,
      is_hidden: false,
      path: None,
    }
  }
}

pub struct SpriteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpriteBuilder<'a, 'b> {
  #[inline]
  pub fn add_position(&mut self, position: flatbuffers::WIPOffset<Coord<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Coord>>(Sprite::VT_POSITION, position);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: flatbuffers::WIPOffset<Size<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Size>>(Sprite::VT_SIZE_, size_);
  }
  #[inline]
  pub fn add_is_hidden(&mut self, is_hidden: bool) {
    self.fbb_.push_slot::<bool>(Sprite::VT_IS_HIDDEN, is_hidden, false);
  }
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Sprite::VT_PATH, path);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpriteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpriteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Sprite<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Sprite<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Sprite");
      ds.field("position", &self.position());
      ds.field("size_", &self.size_());
      ds.field("is_hidden", &self.is_hidden());
      ds.field("path", &self.path());
      ds.finish()
  }
}
pub enum SizeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Size<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Size<'a> {
  type Inner = Size<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Size<'a> {
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 4;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Size { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SizeArgs
  ) -> flatbuffers::WIPOffset<Size<'bldr>> {
    let mut builder = SizeBuilder::new(_fbb);
    builder.add_width(args.width);
    builder.add_height(args.height);
    builder.finish()
  }


  #[inline]
  pub fn height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Size::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Size::VT_WIDTH, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Size<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .finish();
    Ok(())
  }
}
pub struct SizeArgs {
    pub height: f64,
    pub width: f64,
}
impl<'a> Default for SizeArgs {
  #[inline]
  fn default() -> Self {
    SizeArgs {
      height: 0.0,
      width: 0.0,
    }
  }
}

pub struct SizeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SizeBuilder<'a, 'b> {
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(Size::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(Size::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SizeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SizeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Size<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Size<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Size");
      ds.field("height", &self.height());
      ds.field("width", &self.width());
      ds.finish()
  }
}
pub enum FrameOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Frame<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Frame<'a> {
  type Inner = Frame<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Frame<'a> {
  pub const VT_SOUNDS: flatbuffers::VOffsetT = 4;
  pub const VT_SPRITES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Frame { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FrameArgs<'args>
  ) -> flatbuffers::WIPOffset<Frame<'bldr>> {
    let mut builder = FrameBuilder::new(_fbb);
    if let Some(x) = args.sprites { builder.add_sprites(x); }
    if let Some(x) = args.sounds { builder.add_sounds(x); }
    builder.finish()
  }


  #[inline]
  pub fn sounds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Sound<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Sound>>>>(Frame::VT_SOUNDS, None)}
  }
  #[inline]
  pub fn sprites(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Sprite<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Sprite>>>>(Frame::VT_SPRITES, None)}
  }
}

impl flatbuffers::Verifiable for Frame<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Sound>>>>("sounds", Self::VT_SOUNDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Sprite>>>>("sprites", Self::VT_SPRITES, false)?
     .finish();
    Ok(())
  }
}
pub struct FrameArgs<'a> {
    pub sounds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Sound<'a>>>>>,
    pub sprites: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Sprite<'a>>>>>,
}
impl<'a> Default for FrameArgs<'a> {
  #[inline]
  fn default() -> Self {
    FrameArgs {
      sounds: None,
      sprites: None,
    }
  }
}

pub struct FrameBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FrameBuilder<'a, 'b> {
  #[inline]
  pub fn add_sounds(&mut self, sounds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Sound<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_SOUNDS, sounds);
  }
  #[inline]
  pub fn add_sprites(&mut self, sprites: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Sprite<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Frame::VT_SPRITES, sprites);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FrameBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FrameBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Frame<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Frame<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Frame");
      ds.field("sounds", &self.sounds());
      ds.field("sprites", &self.sprites());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Frame`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_frame_unchecked`.
pub fn root_as_frame(buf: &[u8]) -> Result<Frame, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Frame>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Frame` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_frame_unchecked`.
pub fn size_prefixed_root_as_frame(buf: &[u8]) -> Result<Frame, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Frame>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Frame` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_frame_unchecked`.
pub fn root_as_frame_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Frame<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Frame<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Frame` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_frame_unchecked`.
pub fn size_prefixed_root_as_frame_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Frame<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Frame<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Frame and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Frame`.
pub unsafe fn root_as_frame_unchecked(buf: &[u8]) -> Frame {
  flatbuffers::root_unchecked::<Frame>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Frame and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Frame`.
pub unsafe fn size_prefixed_root_as_frame_unchecked(buf: &[u8]) -> Frame {
  flatbuffers::size_prefixed_root_unchecked::<Frame>(buf)
}
#[inline]
pub fn finish_frame_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Frame<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_frame_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Frame<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Frame
}  // pub mod Output
}  // pub mod CoffeeTime

